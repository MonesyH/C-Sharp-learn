redis官网：https://redis.io/docs/manual/patterns/distributed-locks/

# 一、为什么需要分布式锁
多个进程如果需要修改 MySQL 中的同一行记录时，为了避免操作乱序导致数据错误，此时，我们就需要引入「分布式锁」来解决这个问题了。

假设同时有多个请求去调用拨打电话的接口去拨打电话，首先会去数据库中获取当前空闲（即没在拨打的）手机号，拿到之后再去向目标手机拨出。就会出现同时拿到同一个空闲的手机号，而不是各自拿到不同的空闲手机号，导致对同一条空闲手机号数据进行更改状态的操作，出现冲突，如下图：

![高并发打电话](https://upload-images.jianshu.io/upload_images/20387877-18e1829a20344711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 二、redis如何实现锁的效果
redis中有个`SETNX`的命令，表示SET if Not eXists，即如果 key 不存在，才会设置它的值，否则什么也不做。

客户端 1 申请加锁，加锁成功：
```
127.0.0.1:6379> SETNX lock 1
(integer) 1     // 客户端1，加锁成功
```

客户端 2 申请加锁，因为后到达，加锁失败：
```
127.0.0.1:6379> SETNX lock 1
(integer) 0     // 客户端2，加锁失败
```

此时，加锁成功的客户端，就可以去操作「共享资源」，例如，修改 MySQL 的某一行数据，或者调用一个 API 请求。

操作完成后，还要及时释放锁，给后来者让出操作共享资源的机会。如何释放锁呢？

也很简单，直接使用 DEL 命令删除这个 key 即可：
```
127.0.0.1:6379> DEL lock // 释放锁
(integer) 1
```

![大概过程](https://upload-images.jianshu.io/upload_images/20387877-d1da4821026477dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


# 三、如何避免死锁

## 1. 设定租期
但是，上面的方案存在一个很大的问题，当客户端 1 拿到锁后，如果发生下面的场景，就会造成**死锁**：

程序处理业务逻辑异常，没及时释放锁
进程挂了，没机会释放锁
这时，这个客户端就会一直占用这个锁，而其它客户端就**永远**拿不到这把锁了。

比较容易想到的方案是，在申请锁时，给这把锁设置一个**租期**。

在 Redis 中实现时，就是给这个 key 设置一个**过期时间**。这里假设，操作共享资源的时间不会超过 10s，那么在加锁时，给这个 key 设置 10s 过期即可：
```
127.0.0.1:6379> SETNX lock 1    // 加锁
(integer) 1
127.0.0.1:6379> EXPIRE lock 10  // 10s后自动过期
(integer) 1
```

## 2. 保证一起成功
现在的操作，加锁、设置过期是 2 条命令，有没有可能只执行了第一条，第二条却「来不及」执行的情况发生呢？例如：

SETNX 执行成功，执行 EXPIRE 时由于网络问题，执行失败
SETNX 执行成功，Redis 异常宕机，EXPIRE 没有机会执行
SETNX 执行成功，客户端异常崩溃，EXPIRE 也没有机会执行

在 Redis 2.6.12 之后，Redis 扩展了 SET 命令的参数，用这一条命令就可以了：
```
// 一条命令保证原子性执行
127.0.0.1:6379> SET lock 1 EX 10 NX
OK
```

# 四、如何避免锁被别人释放

一般是以下场景：

1. 客户端 1 加锁成功，开始操作共享资源
2. 客户端 1 操作共享资源的时间，超过了锁的过期时间，锁被**自动释放**
3. 客户端 2 加锁成功，开始操作共享资源
4. 客户端 1 操作共享资源完成，释放锁（但释放的是客户端 2 的锁）

客户端 1 操作共享资源完成后，却又释放了客户端 2 的锁
这个问题的重点在于，每个客户端在释放锁时，都是**无脑**操作，并没有检查这把锁是否还**归自己持有**，所以就会发生释放别人锁的风险，这样的解锁流程，很不严谨。

***解决办法是：客户端在加锁时，设置一个只有自己知道的「唯一标识」进去。***
```
// 锁的VALUE设置为UUID
127.0.0.1:6379> SET lock $uuid EX 20 NX
OK
```
>这里假设 20s 操作共享时间完全足够，先不考虑锁自动过期的问题。

之后，在释放锁时，要先判断这把锁是否还归自己持有，伪代码可以这么写：
```
// 锁是自己的，才释放
if redis.get("lock") == $uuid:
    redis.del("lock")
```

>这里释放锁使用的是 GET + DEL 两条命令，这时，又会遇到我们前面讲的“一起执行”的问题了

可能会：
1. 客户端 1 执行 GET，判断锁是自己的
2. 客户端 2 执行了 SET 命令，强制获取到锁（虽然发生概率比较低）
3. 客户端 1 执行 DEL，却释放了客户端 2 的锁

这里就只能写一个Lua脚本来确定这两条命令都执行完再开始执行别的命令:
```
// 判断锁是自己的，才释放
if redis.call("GET",KEYS[1]) == ARGV[1]
then
    return redis.call("DEL",KEYS[1])
else
    return 0
end
```

小结一下，基于 Redis 实现的分布式锁，一个严谨的的流程如下：

1. 加锁：SET $lock_key $unique_id EX $expire_time NX
2. 操作共享资源
3. 释放锁：Lua 脚本，先 GET 判断锁是否归属自己，再 DEL 释放锁

# 五、怎么解决锁过期时间不好评估

前面我们提到，锁的过期时间如果评估不好，这个锁就会有「提前」过期的风险。

当时给的妥协方案是，尽量「冗余」过期时间，降低锁提前过期的概率。

这个方案其实也不能完美解决问题，所以比较好的思路应该是：

加锁时，先设置一个过期时间，然后开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。

在```samcook```这个项目的解决方案是：

有一个计时器，自动尝试保持 Redis 锁密钥处于活动状态。最坏的情况是进程崩溃而没有释放锁，在指定的过期时间后，它会自动被redis过期。

# 六、为什么要用RedLock
之前分析的场景都是，锁在「单个」Redis 实例中可能产生的问题，并没有涉及到 Redis 的部署架构细节。

而我们在使用 Redis 时，一般会采用主从集群 + 哨兵的模式部署，这样做的好处在于，当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。

那当「主从发生切换」时，这个分布锁会依旧安全吗？

有以下场景：
1. 客户端 1 在主库上执行 SET 命令，加锁成功
2. 此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）
3. 从库被哨兵提升为新主库，这个锁在新的主库上，丢失了！

![主从的缺陷](https://upload-images.jianshu.io/upload_images/20387877-30e669b84b7e71d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

为此，Redis 的作者提出一种解决方案，就是我们经常听到的 Redlock（红锁）。

# 七、怎么实现RedLock

## 1. 前提
Redlock 的方案基于 2 个前提：

1. 不再需要部署从库和哨兵实例，只部署主库
2. 但主库要部署多个，官方推荐至少 5 个实例

>也就是说，想用使用 Redlock，你至少要部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例

## 2. 整体流程

1. 客户端先获取「当前时间戳T1」
2. 客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁
3. 如果客户端从 >=3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 < 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败
4. 加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）
5. 加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）

## 3. 理由

### 1) 为什么要在多个实例上加锁？

本质上是为了「容错」，部分实例异常宕机，剩余的实例加锁成功，整个锁服务依旧可用。

### 2) 为什么大多数加锁成功，才算成功？

多个 Redis 实例一起来用，其实就组成了一个「分布式系统」。

在分布式系统中，总会出现「异常节点」，所以，在谈论分布式系统问题时，需要考虑异常节点达到多少个，也依旧不会影响整个系统的「正确性」。

这是一个分布式系统「容错」问题，这个问题的结论是：如果只存在「故障」节点，只要大多数节点正常，那么整个系统依旧是可以提供正确服务的。

### 3) 为什么步骤 3 加锁成功后，还要计算加锁的累计耗时？

因为操作的是多个节点，所以耗时肯定会比操作单个实例耗时更久，而且，因为是网络请求，网络情况是复杂的，有可能存在延迟、丢包、超时等情况发生，网络请求越多，异常发生的概率就越大。

所以，即使大多数节点加锁成功，但如果加锁的累计耗时已经「超过」了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁就没有意义了。

### 4) 为什么释放锁，要操作所有节点？

在某一个 Redis 节点加锁时，可能因为「网络原因」导致加锁失败。

例如，客户端在一个 Redis 实例上加锁成功，但在读取响应结果时，网络问题导致读取失败，那这把锁其实已经在 Redis 上加锁成功了。

所以，释放锁时，不管之前有没有加锁成功，需要释放「所有节点」的锁，以保证清理节点上「残留」的锁。

# 八、在.net 中使用RedLock

[![image.png](https://upload-images.jianshu.io/upload_images/20387877-203778e4a84165be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)](https://i.postimg.cc/YS0GWn7R/Wechat-IMG52.png)

我使用的是：https://github.com/samcook/RedLock.net

具体用法可以直接看GitHub上描述文件README.md.
